# 1 简介

1.6 线程简介
-
  **什么是线程**
  
  线程，有时被称为**轻量级进程（Lightweight Process，LWP）**，是程序执行的最小单位。一个标准的线程由线程ID、当前指令指针（PC）、寄存器集合和堆栈组成。
  
  ![进程线程关系](./pic/programer/thread_process.png)

  **使用多线程原因**
  
  * 某个操作可能会陷入长时间等待，多线程执行可以有效利用等待的时间。
  * 某个操作（常常是计算）会消耗大量的时间，多线程可以保证与用户交互和计算同时进行。
  * 程序逻辑本身就要求并发操作，例如一个多端下载软件。
  * 发挥多核计算机的全部计算能力。
  * 比进程在数据共享方面效率要高很多。

**线程访问权限**

  * 线程私有存储空间
   
    * 栈。
    * 线程局部存储（Thread Local Storage，TLS）。
    * 寄存器（包括PC寄存器），寄存器是执行流的基本数据，因此为线程私有。

  ![线程存储](./pic/programer/thread_private.png)

**线程调度与优先级**

  * 线程调度中的状态
   
    * 运行（Running）：此时线程正在执行。
    * 就绪（Ready）：此时线程可以立即运行，但CPU已经被占用。
    * 等待（Waiting）：此时线程正在等待某一事件（通常是I/O或同步）发生，无法执行。
   
  ![线程状态转移](./pic/programer/thread_status.png)

  * 线程调度方案与算法
  
    * 优先级调度（Priority Schedule）
    * 轮转法（Round Robin）
  
  IO密集型线程总是比CPU密集型线程容易得到优先级的提升。

**Linux多线程**
  
  Linux将所有的执行实体（无论是线程和进程）都称为**任务**（Task），Linux下不同任务之间可以选择共享空间，所有共享了同一个内存空间的多个任务构成一个进程，这些任务也就成了这个进程里的线程。

  Linux创建新任务方式
  
  * fork 复制当前进程。
    
    fork产生和当前进程完全一样的新进程，新进程和当前进程共享一个**写时复制（Copy On Write，COW）的内存空间**，所有速度非常快。

  * exec 使用新的可执行映像覆盖当前可执行映像。

    执行新的可执行文件，一般配合fork使用。一起用于产生新任务。

  * clone 创建子进程并从指定位置开始执行。

    产生一个从指定的位置开始执行，并且（可选的）共享当前进程的内存空间和文件等。可用于创建一个新线程。

1.6.2 线程安全
-
**同步与锁**

* 二元信号（Binary Semaphore）
  
  只有两种状态，占用与非占用。只允许被唯一一个线程独占访问的资源。
  允许多个线程并发访问的资源，多元信号量简称**信号量（Semaphore）**。

* 互斥量（Mutex）
  
  与二元信号很类似，不同点是信号量在整个系统可以被任意线程获取并释放，而互斥量则要求哪个线程获取的就要哪个线程释放。

* 临界区（Critical Section）
  
  与互斥量和信号量的区别在于，后两者在系统的任何进程里都是可见的，而临界区的作用范围仅限于本进程。

* 读写锁（Read-Write Lock）
  
  两种获取方式，**共享的（Shared）** 或**独占的（Exclusive）**。

  | 读写锁状态 | 以共享方式获取 | 以独占方式获取 |
  | ---------- | -------------- | -------------- |
  | 自由       | 成功           | 成功           |
  | 共享       | 成功           | 等待           |
  | 独占       | 等待           | 等待           |

* 条件变量（Condition Variable）

**可重入（Reentrant）与线程安全**

一个函数要成为可重入的，必须具有如下几个特点

* 不使用任何（局部）静态或者全局的非const变量
* 不返回任何（局部）静态或全局的非const变量的指针
* 仅依赖于调用方提供的参数
* 不依赖任何单个资源的锁（mutex等）
* 不调用任何不可重入的函数

可重入是并发安全的强力保障，一个可重入的函数可以在多线程环境下放心使用。

**volatile关键字作用**

* 阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回。
* 阻止编译器调整操作volatile变量的指令顺序，（但是阻止编译器调整指令顺序并不能解决根本问题，因为CPU也会动态调度换序）。

阻止CPU换序的方法是调用CPU提供的 **barrier** 指令，这条指令会阻止CPU将该指令之前的指令交换到它之后。例如：POWERPC 处理器

![barrier](./pic/programer/barrier.png)

1.6.3 多线程内部情况
-
**三种线程模型**

* 一对一模型
  
  一个用户使用的线程就唯一对应一个内核使用的线程（但反过来不一定，一个内核线程在用户态不一定有对应的线程存在）。

  ![thread_model1](./pic/programer/thread_model1.png)
  
  这样线程之间的并发是真正的并发，线程之间执行不会相互影响，可以让多线程程序在多处理器的系统上有更好的表现。
  
  一般直接使用API或系统调用创建的线程均为一对一的线程。例如在Linux里使用 clone （带有CLONE_VM参数）。在Windows里，使用API CreateThread。

  缺点：
  
  * 线程数会受操作系统的限制（一般操作系统会限制内核线程数量）。
  * 许多操作系统内核线程调度时，上下文切换的开销较大，导致用户线程的执行效率下降。

* 多对一模型
  
  将多个用户线程映射到一个内核线程上，线程之间的切换由用户态的代码来进行，比一对一模型切换快速许多。

  ![thread_model2](./pic/programer/thread_model2.png)

  多对一模型一大问题是，如果其中一个用户线程阻塞，那么所有的线程都将无法执行。多对一模型的好处是高效的上下文切换和几乎无限制的线程数量。

* 多对多模型
  
  多对多模型结合了多对一模型和一对一模型的特点，将多个用户线程映射到少数但不止一个内核线程上。

  ![thread_model3](./pic/programer/thread_model3.png)

  在多对多模型中，一个用户线程阻塞并不会使得所有的用户线程阻塞，因为此时还有别的线程可以被调度执行。

# 2 静态链接

2.1 被隐藏的过程
-
**四个步骤：预处理（Prepressing）、编译（Compilation）、汇编（Assembly）、链接（Linking）。**

2.1.1 预编译
-
首先是源代码文件和相关头文件被编译成 **.i** 文件，相当于使用命令
```
$gcc -E hello.c -o hello.i
或者
$cpp hello.c > hello.i
```
预编译过程主要处理那些源代码中的以“#”开始的预编译指令。比如“include“、“#define”等，主要处理规则如下：

* 将所有的“#define”删除，并且展开所有的宏定义。
* 处理所有条件预编译指令，例如：“#if”、“#ifdef”、“#elif”、“#else”、“#endif”。
* 处理“#include”预编译指令，将被包含的文件插入到预编译指令的位置。注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件。
* 删除所有的注释“//”和“/* */”。
* 添加行号和文件名标识，比如 #2 “hello.c” 2，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号。
* 保留所有的 #pragma 预编译指令，因为编译器需要使用它们。

2.1.2 编译
-
编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件。
```
$gcc -S hello.i -o hello.s
```
GCC已经将预编译和编译两个步骤合并成一个步骤，使用 **cc1** 来完成这两个步骤。或使用如下命令
```
$gcc -S hello.c -o hello.s
```

**所有实际上 gcc 这个命令会根据不同的参数要求去调用，预编译器程序 cc1、汇编器 as、链接器 ld。**

2.1.3 汇编
-
汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。
```
$as hello.s -o hello.o
或者
$gcc -c hello.s -o hello.o
或者
$gcc -c hello.c -o hello.o
```

2.1.4 链接
-
2.2 编译器做了什么
-
编译过程分6步
  * 扫描
  * 语法分析
  * 语义分析
  * 源代码优化
  * 代码生成
  * 目标代码优化

![compilation](./pic/programer/compilation_process.png)

2.2.1 词法分析
-
词法分析产生的记号分类

* 关键字
* 标识符
* 字面量（包含数字、字符串等）
* 特殊符号（如加号、等号）

一般使用独立的词法扫描器完成（例如 lex）。另外对于一些有预处理的预言，预处理工作（例如宏替换和文件包含等）一般不归入编译器的范围，而交给一个独立的预处理器完成。

2.2.2 语法分析（Grammar Parser）
-
对词法扫描器产生的记号进行语法分析，从而产生**语法树（Syntax Tree）**。语法分析工具 yacc（Yet Another Compiler Compiler）。

2.2.3 语义分析
-
编译器所能分析的语义是 **静态语义（Static Semantic）**，所谓静态语义是指在编译期可以确定的语义，与之对应的 **动态语义（Dynamic Semantic）** 就是只有在运行期才能确定的语义。

2.2.4 中间语言生成
-
现代编译器有很多层次的优化，**源码级优化器（Source Code Optimizer）** 会在源码级别进行优化。由于直接在语法树上作优化比较困难，所以源码优化器会将整个语法树转换成**中间代码（Intermediate Code）**，常见的中间代码有：三地址码（Three-address Code）和 P-代码（P-Code）。

中间代码使得编译器可以分为前端和后端。编译器前端负责产生机器无关的中间代码，编译器后端将中间代码转换成目标机器代码。这样对于跨平台的编译器而言，针对不同的平台使用同一前端和针对不同机器平台的数个后端。

2.2.5 目标代码生成与优化
-
编译器后端主要包括 **代码生成器（Code Generator）**和**目标代码优化器（Target Code Optimizer）**。

2.3 链接器
-
重新计算各个目标的地址过程叫做 **重定位（Relocation）**。

**符号（Symbol）** 它用来表示一个地址，这个地址可以是一段子程序的起始地址，也可以是一个变量的起始地址。

2.4 静态链接
-