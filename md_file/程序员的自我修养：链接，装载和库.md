### 1 简介

1.6 线程简介

* 什么是线程
  
  线程，有时被称为**轻量级进程（Lightweight Process，LWP）**，是程序执行的最小单位。一个标准的线程由线程ID、当前指令指针（PC）、寄存器集合和堆栈组成。
  
  ![进程线程关系](./pic/programer/thread_process.png)

* 使用多线程原因
  
  * 某个操作可能会陷入长时间等待，多线程执行可以有效利用等待的时间。
  * 某个操作（常常是计算）会消耗大量的时间，多线程可以保证与用户交互和计算同时进行。
  * 程序逻辑本身就要求并发操作，例如一个多端下载软件。
  * 发挥多核计算机的全部计算能力。
  * 比进程在数据共享方面效率要高很多。

* 线程访问权限

  * 线程私有存储空间
   
    * 栈。
    * 线程局部存储（Thread Local Storage，TLS）。
    * 寄存器（包括PC寄存器），寄存器是执行流的基本数据，因此为线程私有。

  ![线程存储](./pic/programer/thread_private.png)

* 线程调度与优先级

  * 线程调度中的状态
   
    * 运行（Running）：此时线程正在执行。
    * 就绪（Ready）：此时线程可以立即运行，但CPU已经被占用。
    * 等待（Waiting）：此时线程正在等待某一事件（通常是I/O或同步）发生，无法执行。
   
  ![线程状态转移](./pic/programer/thread_status.png)

  * 线程调度方案与算法
  
    * 优先级调度（Priority Schedule）
    * 轮转法（Round Robin）
  
  IO密集型线程总是比CPU密集型线程容易得到优先级的提升。

* Linux多线程
  
  Linux将所有的执行实体（无论是线程和进程）都称为**任务**（Task），Linux下不同任务之间可以选择共享空间，所有共享了同一个内存空间的多个任务构成一个进程，这些任务也就成了这个进程里的线程。

  Linux创建新任务方式
  
  * fork 复制当前进程。
    
    fork产生和当前进程完全一样的新进程，新进程和当前进程共享一个**写时复制（Copy On Write，COW）的内存空间**，所有速度非常快。

  * exec 使用新的可执行映像覆盖当前可执行映像。

    执行新的可执行文件，一般配合fork使用。一起用于产生新任务。

  * clone 创建子进程并从指定位置开始执行。

    产生一个从指定的位置开始执行，并且（可选的）共享当前进程的内存空间和文件等。可用于创建一个新线程。

1.6.2 线程安全

**同步与锁**

* 二元信号（Binary Semaphore）
  
  只有两种状态，占用与非占用。只允许被唯一一个线程独占访问的资源。
  允许多个线程并发访问的资源，多元信号量简称**信号量（Semaphore）**。

* 互斥量（Mutex）
  
  与二元信号很类似，不同点是信号量在整个系统可以被任意线程获取并释放，而互斥量则要求哪个线程获取的就要哪个线程释放。

* 临界区（Critical Section）
  
  与互斥量和信号量的区别在于，后两者在系统的任何进程里都是可见的，而临界区的作用范围仅限于本进程。

* 读写锁（Read-Write Lock）
  
  两种获取方式，**共享的（Shared）** 或**独占的（Exclusive）**。

  | 读写锁状态 | 以共享方式获取 | 以独占方式获取 |
  | ---------- | -------------- | -------------- |
  | 自由       | 成功           | 成功           |
  | 共享       | 成功           | 等待           |
  | 独占       | 等待           | 等待           |

* 条件变量（Condition Variable）

**可重入（Reentrant）与线程安全**

一个函数要成为可重入的，必须具有如下几个特点

* 不使用任何（局部）静态或者全局的非const变量
* 不返回任何（局部）静态或全局的非const变量的指针
* 仅依赖于调用方提供的参数
* 不依赖任何单个资源的锁（mutex等）
* 不调用任何不可重入的函数

可重入是并发安全的强力保障，一个可重入的函数可以在多线程环境下放心使用。

**volatile关键字作用**

* 阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回。
* 阻止编译器调整操作volatile变量的指令顺序，（但是阻止编译器调整指令顺序并不能解决根本问题，因为CPU也会动态调度换序）。

阻止CPU换序的方法是调用CPU提供的 **barrier** 指令，这条指令会阻止CPU将该指令之前的指令交换到它之后。例如：POWERPC 处理器

![barrier](./pic/programer/barrier.png)

1.6.3 多线程内部情况

**三种线程模型**

* 一对一模型
  
  一个用户使用的线程就唯一对应一个内核使用的线程（但反过来不一定，一个内核线程在用户态不一定有对应的线程存在）。

  ![thread_model1](./pic/programer/thread_model1.png)
  
  这样线程之间的并发是真正的并发，线程之间执行不会相互影响，可以让多线程程序在多处理器的系统上有更好的表现。
  
  一般直接使用API或系统调用创建的线程均为一对一的线程。例如在Linux里使用 clone （带有CLONE_VM参数）。在Windows里，使用API CreateThread。

  缺点：
  
  * 线程数会受操作系统的限制（一般操作系统会限制内核线程数量）。
  * 许多操作系统内核线程调度时，上下文切换的开销较大，导致用户线程的执行效率下降。

* 多对一模型
  
  将多个用户线程映射到一个内核线程上，线程之间的切换由用户态的代码来进行，比一对一模型切换快速许多。

  ![thread_model2](./pic/programer/thread_model2.png)

  多对一模型一大问题是，如果其中一个用户线程阻塞，那么所有的线程都将无法执行。多对一模型的好处是高效的上下文切换和几乎无限制的线程数量。

* 多对多模型
  
  多对多模型结合了多对一模型和一对一模型的特点，将多个用户线程映射到少数但不止一个内核线程上。

  ![thread_model3](./pic/programer/thread_model3.png)

  在多对多模型中，一个用户线程阻塞并不会使得所有的用户线程阻塞，因为此时还有别的线程可以被调度执行。

  ### 2 静态链接