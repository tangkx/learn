# 高性能Mysql study notes

1.1 事务特性 (ACID原则)
* 原子性(atomicity)
* 一致性(consistency)
* 隔离性(isolation)
* 持久性(durability)

1.2 事务隔离级别
* 未提交读(read uncommitted)

    事务中的修改，即使没有提交，对其他事务也是可见的，事务可以读取未提交的数据也被称为**脏读**(Dirty Read)。

* 提交读(read committed)
  
    一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的，这个级别也叫做**不可重复读**(nonrepeatable read)。

* 可重复读(repeatable read)
  
    可重复读解决了脏读的问题，该级别保证了在同一事务中多次读取同样的记录的结果是一致的，但是理论上，此级别无法解决**幻读**的问题，**幻读**是指当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行，**(Mysql默认事务隔离级别)**。

* 可串行化(serializable)
    
    最高隔离级别，通过强制事务串行执行，避免前面的幻读问题。serializable会在堆区的每一行数据上加锁，会导致大量超时和锁争用问题。

表1-1：ANSI SQL隔离级别

| 隔离级别 | 脏读  | 不可重复读 | 幻读  | 加锁读 |
| :------: | :---: | :--------: | :---: | :----: |
| 未提交读 |  Yes  |    Yes     |  Yes  |   No   |
|  提交读  |  No   |    Yes     |  Yes  |   No   |
| 可重复读 |  No   |     No     |  Yes  |   No   |
| 可串行化 |  No   |     No     |  No   |  Yes   

1.3.1 事务日志

事务日志可以帮助提高事务的效率。修改表的数据时只需要修改其内存拷贝，再将修改行为记录持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。在事务持久以后，内存中被修改的数据在后台可以慢慢刷回到磁盘，这种方式称为**预写式日志(Write-Ahead Logging)**，修改数据需要写两次磁盘。

如果数据的修改已经记录到事务日志并持久化，但是数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。

1.3.2 Mysql中的事务

* Mysql提供的两种事务型的存储引擎
  
  * InnoDB
  * NDB Cluster

* 自动提交(autocommit)
  
  Mysql默认采用自动提交模式。在当前连接中，可以通过设置 **autocommit** 变量来启用或者禁用自动提交模式。
    
    ```
    mysql> show variables like 'autocommit';

    mysql> set autocommit = 1;
    ```
  
  还有一些命令在执行之前会强制执行**commit**提交当前事务，例如：alter table(会导致大量数据改变的操作)，lock table。

* Mysql设置隔离级别

```
mysql> set session transaction isolation level "隔离级别";
```

* 隐式和显式锁定
  
  * 隐式
    
    在事务执行过程中，随时都可以执行锁定，所有的锁在执行**commit**或者**rollback**的时候才会释放，InnoDB会根据隔离级别在需要的时候自动加锁。
  
  * 显式
    
    InnoDB支持特定的语句进行显示锁定，这些语句不属于SQL规范。

    ```
    mysql> select ... lock in share mode;

    mysql> select ... for update;
    ```
  Mysql也支持**lock tables**和**unlock tables**语句，这是在服务层实现的，和存储引擎无关。但是并不能替代事务。

1.4 多版本并发控制(MVCC)

* 概念
  
  基于并发性能的考虑所实现，是行级锁的一个变种，在很多情况下避免了加锁操作，因此开销更低。

* 实现
  
  通过保存数据在某个时间点的快照。也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。

* 实现方式

  * 乐观(optimistic)并发控制
  * 悲观(pessimistic)并发控制
  
* InnoDB MVVC实现
  
  通过在每行记录后面保存两个隐藏的列来实现。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。存储的不是时间值，而是版本号(system version number)。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

  SELECT
    
        InnoDB会根据以下两个条件检查每行记录
        
        a. InnoDB只查找版本号小于会等于事务的系统版本号的数据行，这样可以保证事务读取的行，要么在事务开始前已经存在，要么是事务自身插入或修改过的。
        
        b. 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。

        只要符合上述条件的记录，才能返回作为查询结果。
    
  INSERT

        InnoDB为新插入的每一行保存当前系统版本号作为行版本号。

  DELETE

        InnoDB为删除的每一行保存当前系统版本号作为行删除标识。

  UPDATE

        InnoDB为插入的一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。

  保存这两个额外系统版本号，使大多数读操作都可以不用加锁。MVCC只在**提交读**和**可重复读**这两个隔离级别下工作。因为**未提交读**总是读取最新的数据行，而**可串行化**会对所有读取的行加锁，所有与MVCC不兼容。

 4.1 选择优化的数据类型
  
* 更小的通常更好

* 简单就好

  * 应该使用MySQL内建的数据类型而不是字符串存储日期和时间。
  * 应该用整型存储IP地址。

* 尽量避免 NULL

  查询包含NULL的列，对MySQL来说更难优化，因为可为NULL的列使得索引，索引统计和值比较都更复杂。可为NULL的列在MySQL中需要特殊处理，也会使用更多的存储空间。

  **例外**：InnoDB中使用单独的位(bit)存储NULL值，所有对于稀疏数据有很好的空间效率。

4.1.1 整数类型

* tinyint   (8bit)
* smallint  (16bit)
* mediumint (24bit)
* int       (32bit)
* bigint    (64bit)
  
整数类型有可选的 **unsigned** 属性表示不允许负值，例如：tinyint unsigned。

4.1.2 实数类型

实数是带有小数部分的数字，不只是存储小数，也可以存储整数。

* decimal 可以存储比 bigint 更大的整数，也可以用于存储精确的小数。**decimal**只是一种存储类型，在计算时会转换成**double**类型。

* double

* float

建议只指定数据类型，不指定精度。应使用整数来替代小数的存储计算(通过根据小数的位数放大对应的倍数来实现)，可以避免浮点存储计算不精确和decimal精确计算代价高的问题。

4.1.3 字符串类型

* char 
  
  存储定长字符串，MySQL总是根据定义的字符串长度分配足够的空间，存储 char 值时，MySQL会删除所有末尾空格。适合存储短字符串或者所有值都接近同一个长度。例如：存储密码的**MD5值**，对于经常变更的数据，char 比 varchar 更好，因为定长的 char 类型不容易产生碎片。对于非常短的列，char 比 varchar 在存储空间上也更有效率。因为 varchar 需要额外字节存储字符串长度。

* varchar
  
  存储可变长字符串，比定长类型更省空间，因为它仅使用必要的空间。例外（如果 MySQL 表使用 **row_format = fixed** 创建的话，每一行都会使用定长存储，会浪费空间）。

  需要1或2个额外字节记录字符串长度（列的最大长度小于或等于255，使用1个字节表示，否则使用2个字节）。

* binary （存储二进制字符串）

  存储字节码而不是字符，MySQL 使用 **\0** 填充二进制字符串而不是**空格**，检索时不会去掉填充值。比较时每次按一个字节的数值进行比较，比字符比较简单且更快。

* varbinary （同 binary）

* blob （存储更大数据，二进制字符串）

  * tinyblob
  * smallblob，blob（二者一样）
  * mediumblob
  * longblob

* text （存储更大数据，字符串）
  
  * tinytext
  * smalltext，text（二者一样）
  * mediumtext
  * longtext

* extra notice
  
  * MySQL将 blob 和 text 值当作一个独立的对象处理，在存储时通常做特殊处理。当两者的值太大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1~4个字节存储一个指针，然后在外部存储区域存储实际的值。

  * blob类型存储的时二进制数据，没有排序规则或字符集，而text类型有字符集和排序规则。

  * 这两种类型的排序是只对列的最前 max_sort_length 字节进行排序而不是整个字符串。如果只需要排序前面一小部分字符，则可以减少 max_sort_length 的配置，或使用 order by sustring(column, length)。

  * MySQL不能将 blob 和 text 列全部长度的字符串进行索引，也不能使用这些索引消除排序。

  * **如果 explain 执行计划的 Extra 列包含 “Using temporary”，则说明这个查询使用了隐式临时表。**

**使用枚举（ENUM）代替字符串类型**

* MySQL在存储枚举时非常紧凑，会根据列表值的数量压缩到一个或者两个字节中。

* MySQL在内部会将每个值在列表中的位置保存为整数，并且在表的 .frm 文件中保存 **“数字-字符串”** 映射关系的 “查找表”。

* 枚举字段是按照内部存储的整数而不是定义的字符串进行排序的。可以在查询中使用 field() 函数显式地指定顺序，但这会导致MySQL无法利用索引消除排序。

```
mysql> select e from enum_test order by field(e, 'apple', 'dog', 'fish');
```

4.1.4 日期和时间类型

* datetime

  * 范围从 1001年到9999年，精度为**秒**
  * 把日期和时间封装到格式为 YYYYMMDDHHMMSS的整数中，与时区无关。使用8个字节存储空间。

* timestamp